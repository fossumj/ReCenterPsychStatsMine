LowMean <- digits(GroupMeans$Accurate[2],3)
LowMean
HighMean <- digits(GroupMeans$Accurate[3],3)
HighMean
nGroup <- accSIM30 %>% count(COND)
nGroup
nControl <- nGroup$n[1]
nControl
nLow <- nGroup$n[2]
nLow
nHigh<- nGroup$n[3]
nHigh
#Calculated by using object names from our calculations
SSM <- nControl*(ControlMean - GrandMean)^2 + nLow*(LowMean - GrandMean)^2 + nHigh*(HighMean - GrandMean)^2
SSM
#calculated by specifying the actual values from our calculations
30*(1.756 - 1.603)^2 + 30*(1.900 - 1.603)^2 + 30*(1.153 - 1.603)^2
#Both result in the same
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
SSM <- digits (SSM,3)
SSM
SDs <- aggregate (Accurate ~ COND, accSIM30, sd)
SDs
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
sdControl <- digits(SDs$Accurate[1],3)
sdControl
sdLow <- digits(SDs$Accurate[2],3)
sdLow
sdHigh <- digits(SDs$Accurate[3],3)
sdHigh
#the standard deviation of the control group, when squared should equal the variance reported in the next chunk
sdControl^2
VARs <- aggregate (Accurate ~ COND, accSIM30, var)
VARs
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
varControl <- digits(VARs$Accurate[1],3)
varControl
varLow <- digits(VARs$Accurate[2],3)
varLow
varHigh <- digits(VARs$Accurate[3],3)
varHigh
#Calculated by using object names from our calculations
SSR <- varControl*(nControl-1) + varLow*(nLow-1) + varHigh*(nHigh-1)
#Re-calculated by specifying the actual values from our calculations
SSR
0.212*(30-1) + 0.397*(30-1) + 0.434*(30-1)
#Both result in the same
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
dfT <- 89
dfM <- 2
dfR <- 87
#Calculated by using object names from our calculations
SSM + SSR
#Re-calculated by specifying the actual values from our calculations
9.432 + 30.247
#Both result in the same
# mean squares for the model
#Calculated by using object names from our calculations
MSM <- SSM/dfM
MSM
#Re-calculated by specifying the actual values from our calculations
9.432/2
#Both result in the same
#Calculated by using object names from our calculations
Fratio <- MSM / MSR
# mean squares for the residual
#Calculated by using object names from our calculations
MSR <- SSR/ dfR
MSR
#calculated by specifying the actual values from our calculations
30.247/87
#Both result in the same
#Calculated by using object names from our calculations
Fratio <- MSM / MSR
Fratio
#calculated by specifying the actual values from our calculations
4.716/0.348
#Both result in the same
#looking up the F critical values
qf(.05, 2, 87, lower.tail=FALSE)#Model F critical value
#we name the function
#in parentheses we list the object that is the dataframe
#the $ sign precedes the specific variable for which we want the information
psych::describe(accSIM30$Accurate)
#It is unnecessary to create an object, but an object allows you to do cool stuff, like write it to a .csv file and use that as a basis for APA style tables
#In this script we can think "Accurate by COND" meaning that the descriptives for accuracy will be grouped by COND which is a categorical variable
#mat = TRUE means we will get the output in matrix (table) form
#digits = 3 means output will be rounded to 3 decimal places
#data = accSIM30 is a different (I think easier) way to identify the object that holds the dataframe
des.mat <- psych::describeBy (Accurate ~ COND, mat=TRUE, digits=3, data=accSIM30)
#describeBy(accSIM30$Accurate, accSIM30$COND, mat=TRUE)
des.mat #let's you see the matrix object
write.csv (des.mat, file="Table1.csv") #optional to write it to a .csv file
#library(rstatix)
shapiro <- accSIM30 %>%
group_by(COND) %>%
rstatix::shapiro_test(Accurate)
shapiro
shapiro <- accSIM30 %>%
group_by(COND) %>%
rstatix::shapiro_test(Accurate)
shapiro
#Our set up is similar:  Accurate by condition, followed by the object that holds the dataframe, followed by the instruction to center the analysis around the mean
levene <- car::leveneTest (Accurate ~ COND, accSIM30, center=mean)
levene
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
df1levene<- digits(levene$Df[1],0)
df1levene
df2levene<- digits(levene$Df[2],0)
df2levene
Flevene <- digits(levene$"F value"[1],3)
Flevene
plevene <- digits(levene$"Pr(>F)"[1],3)
plevene
#the script looks familiar, "Accurate by Condition"
omnibus <- aov(Accurate ~ COND, data = accSIM30) #DV ~ IV  I say, "DV by IV"
summary (omnibus) #prints the ANOVA output
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
df1omnibus<- digits(summary(omnibus)[[1]][1, "Df"],0)
df1omnibus
df2omnibus<- digits(summary(omnibus)[[1]][2, "Df"],0)
df2omnibus
SSMomnibus<- digits(summary(omnibus)[[1]][1, "Sum Sq"],3)
SSMomnibus
SSRomnibus<- digits(summary(omnibus)[[1]][2, "Sum Sq"],3)
SSRomnibus
SSTomnibus <- digits((SSMomnibus + SSRomnibus),3)
SSTomnibus
MSMomnibus<- digits(summary(omnibus)[[1]][1, "Mean Sq"],3)
MSMomnibus
MSRomnibus<- digits(summary(omnibus)[[1]][2, "Mean Sq"],3)
MSRomnibus
Fomnibus<- digits(summary(omnibus)[[1]][1, "F value"],3)
Fomnibus
pomnibus<- digits(summary(omnibus)[[1]][1, "Pr(>F)"],3)
pomnibus
names(omnibus)
model.tables (omnibus, "means")
plot(omnibus)
#Calculated using the object names
SSMomnibus / (SSMomnibus + SSRomnibus)
#Calculated by using the numeric values
9.432/(9.432 + 30.246)
#Optiosn should produce the same result
#Re-calculated by using the numeric values
9.432/(9.432 + 30.246)
#Both options should produce the same result
lsr::etaSquared(omnibus)
pairwise.t.test(accSIM30$Accurate, accSIM30$COND, p.adj = "none")
#can swap "bonf" or "holm" for p.adj
citr:::insert_citation()
summary.lm(omnibus)
#Contrast1  compares Control against the combined effects of Low and High.
contrast1 <- c(-2,1,1)
#Contrast2 excludes Control; compares Low to High.
contrast2 <- c(0,-1,1)
#binding the contrasts together
contrasts(accSIM30$COND)<-cbind(contrast1, contrast2)
accSIM30$COND
#create a new object, the ANOVA looks the same, but it will now consider the contrasts (this is where order-of-operations matters)
accPlanned <- aov(Accurate ~ COND, data = accSIM30)
summary.lm(accPlanned)
contrasts(accSIM30$COND)<-cbind(c(-2,1,1), c(0,-1,1))
oneway.test (Accurate ~ COND, data = accSIM30)
effectsize::eta2_to_f(.238)
library(pwr)
pwr.anova.test (k = 3, f = .5589, sig.level = .05, power = .80)
pwr::pwr.anova.test (k = 3, f = .5589, sig.level = .05, power = .80)
pwr::pwr.anova.test (k = 3, f = .1, sig.level = .05, power = .80)
pwr::pwr.anova.test (k = 3, f = .1, sig.level = .05, power = .80)
# table.number = 1 assigns a table number to the top of the table
# filename = "Table1.doc" writes the table to Microsoft Word and puts it in your project folder
apaTables::apa.1way.table(iv=COND, dv=Accurate, show.conf.interval = TRUE, data=accSIM30, table.number = 1, filename = "Table1.doc")
1.76 - 1.15#calculating mean difference between control and high
1.90 - 1.15#calculating mean difference between low and high
1.76 - 1.90#calculating mean difference between  control and low
apaTables::apa.aov.table (omnibus, table.number = 2, filename = "Table2.doc")
plotmeans (formula = Accurate ~ COND, data = accSIM30, xlab = "Racial Loading Condition", ylab = "Accuracy of Confederate's Impression", n.label = FALSE)
lsr::etaSquared(omnibus)
citr:::insert_citation()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
#will install the package if not already installed
#if(!require(tidyverse)){install.packages("tidyverse")} #manipulate data
#if(!require(psych)){install.packages("psych")}
#if(!require(ggpubr)){install.packages("ggpubr")} #easy plots
#if(!require(rstatix)){install.packages("rstatix")} #pipe-friendly R functions
#if(!require(data.table)){install.packages("data.table")} #pipe-friendly R functions
#if(!require(reshape2)){install.packages("reshape2")} #pipe-friendly R functions
#if(!require(WebPower)){install.packages("WebPower")} #power analysis tools for repeated measures
#if(!require(MASS)){install.packages("MASS")} #power analysis tools for repeated measures
set.seed(2022)
ID<-factor(c(rep(seq(1,8),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(24,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,8) #repeats pre, post, follow-up once each, 8 times
Amodeo_long<-data.frame(ID, Wave, Resilience)
#OneWay_mod<-aov(Resilience~Wave + Error(ID/(Wave)), AmodeoSIM)
#summary(OneWay_mod)
#model.tables(OneWay_mod,"means")
str(Amodeo_long)
Amodeo_long$Wave <- factor(Amodeo_long$Wave, levels = c("Pre", "Post", "FollowUp"))
str(Amodeo_long)
library(reshape2)
# Create a new df (Amodeo_wide)
# Identify the original df
# We are telling it to connect the values of the Resilience variable its respective Wave designation
Amodeo_wide <- reshape2::dcast(data = Amodeo_long, formula =ID~Wave, value.var = "Resilience")
#doublecheck to see if they did what you think
str(Amodeo_wide)
Amodeo_wide$ID <- factor(Amodeo_wide$ID)
str(Amodeo_long)
library(psych)
psych::describeBy(Amodeo_long$Resilience, Wave, mat = TRUE, data = Amodeo_long)
library(psych)
psych::describeBy(Amodeo_long$Resilience, Wave, mat = TRUE, data = Amodeo_long, digits = 3)
#Note. Recently my students and I have been having intermittent struggles with the describeBy function in the psych package. We have noticed that it is problematic when using .rds files and when using data directly imported from Qualtrics. If you are having similar difficulties, try uploading the .csv file and making the appropriate formatting changes.
psych::describe(Amodeo_wide, digits = 3)
psych::describe(Amodeo_wide)
boxplot (Resilience ~ Wave, data = Amodeo_long, xlab = "Wave", ylab = "Resilience", n.label = TRUE)
mean(Amodeo_long$Resilience)
library(tidyverse)
Amodeo_long <- Amodeo_long %>%
mutate(m_dev = Resilience-mean(Resilience))
library(tidyverse)
Amodeo_long <- Amodeo_long %>%
mutate(m_dev = Resilience-mean(Resilience))
library(tidyverse)
Amodeo_long <- Amodeo_long %>%
mutate(m_dev = Resilience-mean(Resilience))
head(Amodeo_long)
sum(Amodeo_long$m_dev)
Amodeo_long <- Amodeo_long %>%
mutate(m_devSQ = m_dev^2)
head(Amodeo_long)
sum(Amodeo_long$m_devSQ)
psych::describeBy(Resilience ~ ID, data = Amodeo_long, mat = TRUE, digits = 3)
(.605^2*(3-1)) + (.760^2*(3-1)) + (.992^2*(3-1))+ (.568^2*(3-1))+ (.824^2*(3-1))+ (.146^2*(3-1))+ (.248^2*(3-1)) + (.553^2*(3-1))
psych::describe(Amodeo_wide)
mean(Amodeo_long$Resilience)
#looking up the F critical values
qf(.05, 2, 14, lower.tail=FALSE)#Model F critical value
#looking up the F critical values
qf(.05, 2, 14, lower.tail=FALSE)#Model F critical value
#Note that we are creating an object (bxp) from our work. This script creates the basic boxplot, we will add to it (by using the object) later.
bxp <- ggpubr::ggboxplot(Amodeo_long, x = "Wave", y = "Resilience", add = "point", xlab = "Assessment Wave", ylab = "Self-Perception of Resilience")
bxp
Amodeo_long %>%
group_by(Wave)%>%
rstatix::identify_outliers(Resilience)
#?identify_outliers
#?identify_outliers
head(Amodeo_long)
#?identify_outliers
glimpse(Amodeo_long)
Amodeo_long %>%
group_by(Wave)%>%
rstatix::identify_outliers(Resilience)
#?identify_outliers
View(Amodeo_long)
Amodeo_long %>%
rstatix::group_by(Wave)%>%
rstatix::identify_outliers(Resilience)
#?identify_outliers
View(Amodeo_wide)
library(rstatix)
Amodeo_long %>%
group_by(Wave)%>%
identify_outliers(Resilience)
#?identify_outliers
Amodeo_long %>%
group_by(Wave)%>%
rstatix::identify_outliers(Resilience)
#?identify_outliers
psych::describeBy(Resilience ~ Wave, mat=TRUE, data = Amodeo_long)
Amodeo_long %>%
group_by(Wave) %>%
shapiro_test(Resilience)
ggqqplot(Amodeo_long, "Resilience", facet.by = "Wave")
ggpubr::ggqqplot(Amodeo_long, "Resilience", facet.by = "Wave")
pwc <- Amodeo_long %>%
pairwise_t_test(Resilience~Wave, paired = TRUE, p.adjust.method = "bonferroni")
pwc
pwc <- Amodeo_long %>%
pairwise_t_test(Resilience~Wave, paired = TRUE, p.adjust.method = "bonferroni")
pwc
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
ggplot2::stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
ggpubr::stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
pwc <- Amodeo_long %>%
pairwise_t_test(Resilience~Wave, paired = TRUE, p.adjust.method = "bonferroni")
pwc
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
library(ggpubr)
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
#will install the package if not already installed
#if(!require(tidyverse)){install.packages("tidyverse")} #manipulate data
#if(!require(psych)){install.packages("psych")}
#if(!require(ggpubr)){install.packages("ggpubr")} #easy plots
#if(!require(rstatix)){install.packages("rstatix")} #pipe-friendly R functions
#if(!require(data.table)){install.packages("data.table")} #pipe-friendly R functions
#if(!require(reshape2)){install.packages("reshape2")} #pipe-friendly R functions
#if(!require(WebPower)){install.packages("WebPower")} #power analysis tools for repeated measures
#if(!require(MASS)){install.packages("MASS")} #power analysis tools for repeated measures
set.seed(2022)
ID<-factor(c(rep(seq(1,8),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(24,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,8) #repeats pre, post, follow-up once each, 8 times
Amodeo_long<-data.frame(ID, Wave, Resilience)
#OneWay_mod<-aov(Resilience~Wave + Error(ID/(Wave)), AmodeoSIM)
#summary(OneWay_mod)
#model.tables(OneWay_mod,"means")
str(Amodeo_long)
Amodeo_long$Wave <- factor(Amodeo_long$Wave, levels = c("Pre", "Post", "FollowUp"))
str(Amodeo_long)
library(reshape2)
# Create a new df (Amodeo_wide)
# Identify the original df
# We are telling it to connect the values of the Resilience variable its respective Wave designation
Amodeo_wide <- reshape2::dcast(data = Amodeo_long, formula =ID~Wave, value.var = "Resilience")
#doublecheck to see if they did what you think
str(Amodeo_wide)
Amodeo_wide$ID <- factor(Amodeo_wide$ID)
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
#saveRDS(Amodeo_long, "Amodeo_longRDS.rds")
#saveRDS(Amodeo_wide, "Amodeo_wideRDS.rds")
#bring back the simulated dat from an .rds file
#Amodeo_long <- readRDS("Amodeo_longRDS.rds")
#Amodeo_wide <- readRDS("Amodeo_wideRDS.rds")
#write the simulated data  as a .csv
#write.table(Amodeo_long, file="Amodeo_longCSV.csv", sep=",", col.names=TRUE, row.names=FALSE)
#write.table(Amodeo_wide, file="Amodeo_wideCSV.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
#Amodeo_long <- read.csv ("Amodeo_longCSV.csv", header = TRUE)
#Amodeo_wide <- read.csv ("Amodeo_wideCSV.csv", header = TRUE)
str(Amodeo_long)
library(psych)
psych::describeBy(Amodeo_long$Resilience, Wave, mat = TRUE, data = Amodeo_long, digits = 3)
#Note. Recently my students and I have been having intermittent struggles with the describeBy function in the psych package. We have noticed that it is problematic when using .rds files and when using data directly imported from Qualtrics. If you are having similar difficulties, try uploading the .csv file and making the appropriate formatting changes.
psych::describe(Amodeo_wide)
boxplot (Resilience ~ Wave, data = Amodeo_long, xlab = "Wave", ylab = "Resilience", n.label = TRUE)
mean(Amodeo_long$Resilience)
library(tidyverse)
Amodeo_long <- Amodeo_long %>%
mutate(m_dev = Resilience-mean(Resilience))
head(Amodeo_long)
sum(Amodeo_long$m_dev)
Amodeo_long <- Amodeo_long %>%
mutate(m_devSQ = m_dev^2)
head(Amodeo_long)
sum(Amodeo_long$m_devSQ)
psych::describeBy(Resilience ~ ID, data = Amodeo_long, mat = TRUE, digits = 3)
(.605^2*(3-1)) + (.760^2*(3-1)) + (.992^2*(3-1))+ (.568^2*(3-1))+ (.824^2*(3-1))+ (.146^2*(3-1))+ (.248^2*(3-1)) + (.553^2*(3-1))
psych::describe(Amodeo_wide)
mean(Amodeo_long$Resilience)
(8*(6.14 - 6.017)^2) + (8*(6.33 - 6.017)^2) + (8*(5.59 - 6.017)^2)
#df is 3-1 = 2
6.636 - 2.363
16-2
11.66 - 6.64
23-16
# mean squares for the model
2.36/2
# mean squares for the residual
4.27 / 14
1.18 / .305
#looking up the F critical values
qf(.05, 2, 14, lower.tail=FALSE)#Model F critical value
#Note that we are creating an object (bxp) from our work. This script creates the basic boxplot, we will add to it (by using the object) later.
bxp <- ggpubr::ggboxplot(Amodeo_long, x = "Wave", y = "Resilience", add = "point", xlab = "Assessment Wave", ylab = "Self-Perception of Resilience")
bxp
Amodeo_long %>%
group_by(Wave)%>%
rstatix::identify_outliers(Resilience)
#?identify_outliers
psych::describeBy(Resilience ~ Wave, mat=TRUE, data = Amodeo_long)
Amodeo_long %>%
group_by(Wave) %>%
shapiro_test(Resilience)
ggpubr::ggqqplot(Amodeo_long, "Resilience", facet.by = "Wave")
str(Amodeo_long)
RM_AOV <- rstatix::anova_test(data = Amodeo_long, dv = Resilience, wid = ID, within = Wave)
RM_AOV
pwc <- Amodeo_long %>%
pairwise_t_test(Resilience~Wave, paired = TRUE, p.adjust.method = "bonferroni")
pwc
library(ggpubr)
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
MASS::write.matrix(pwc, sep = ",", file = "PWC.csv")
(3 * (3-1))/2
.05/3
pwc <- pwc %>% ggpubr::add_xy_position(x = "Wave")
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
ggpubr::stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
pwc <- pwc %>% add_xy_position(x = "Wave")
bxp +
ggpubr::stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(RM_AOV, detailed = TRUE),
caption = get_pwc_label(pwc)
)
effectsize::eta2_to_f(.203)
WebPower::wp.rmanova(n=8, ng=1, nm=3, f = .5047, nscor = .689, alpha = .05, power = NULL, type = 1)
wp.rmanova(n=NULL, ng=1, nm=3, f = .5047, nscor = .689, alpha = .05, power = .80, type = 1)
WebPower::wp.rmanova(n=8, ng=1, nm=3, f = .5047, nscor = .689, alpha = .05, power = NULL, type = 1)
WebPower::wp.rmanova(n=NULL, ng=1, nm=3, f = .5047, nscor = .689, alpha = .05, power = .80, type = 1)
citr:::insert_citation()
set.seed(2022)
ID<-factor(c(rep(seq(1,50),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(24,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,50) #repeats pre, post, follow-up once each, 8 times
Amodeo50_long<-data.frame(ID, Wave, Resilience)
set.seed(2022)
ID<-factor(c(rep(seq(1,50),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(150,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,50) #repeats pre, post, follow-up once each, 8 times
Amodeo50_long<-data.frame(ID, Wave, Resilience)
OneWay_mod<-rstatix::aov(Resilience~Wave + Error(ID/(Wave)), AmodeoSIM)
set.seed(2022)
ID<-factor(c(rep(seq(1,50),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(150,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,50) #repeats pre, post, follow-up once each, 8 times
Amodeo50_long<-data.frame(ID, Wave, Resilience)
OneWay_mod<-aov(Resilience~Wave + Error(ID/(Wave)), AmodeoSIM)
set.seed(2022)
ID<-factor(c(rep(seq(1,50),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(150,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,50) #repeats pre, post, follow-up once each, 8 times
Amodeo50_long<-data.frame(ID, Wave, Resilience)
OneWay_mod50<-aov(Resilience~Wave + Error(ID/(Wave)), Amodeo50_long)
summary(OneWay_mod50)
model.tables(OneWay_mod50,"means")
View(Amodeo50_long)
pwc <- Amodeo50_long %>%
pairwise_t_test(Resilience~Wave, paired = TRUE, p.adjust.method = "bonferroni")
pwc
set.seed(2022)
ID<-factor(c(rep(seq(1,50),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(150,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,50) #repeats pre, post, follow-up once each, 8 times
Amodeo50_long<-data.frame(ID, Wave, Resilience)
set.seed(2022)
ID<-factor(c(rep(seq(1,50),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(150,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,50) #repeats pre, post, follow-up once each, 8 times
Amodeo50_long<-data.frame(ID, Wave, Resilience)
View(Amodeo50_long)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
#will install the package if not already installed
#if(!require(tidyverse)){install.packages("tidyverse")} #manipulate data
#if(!require(psych)){install.packages("psych")}
#if(!require(ggpubr)){install.packages("ggpubr")} #easy plots
#if(!require(rstatix)){install.packages("rstatix")} #pipe-friendly R functions
#if(!require(data.table)){install.packages("data.table")} #pipe-friendly R functions
#if(!require(reshape2)){install.packages("reshape2")} #pipe-friendly R functions
#if(!require(WebPower)){install.packages("WebPower")} #power analysis tools for repeated measures
#if(!require(MASS)){install.packages("MASS")} #power analysis tools for repeated measures
set.seed(2022)
ID<-factor(c(rep(seq(1,8),each=3)))#gives me 8 numbers, assigning each number 3 consecutive spots, in sequence
Resilience<-rnorm(24,mean=c(5.7,6.21,6.26),sd=c(.88,.79,.37)) #gives me a column of 24 numbers with the specified Ms and SD
Wave<-rep(c("Pre","Post", "FollowUp"),each=1,8) #repeats pre, post, follow-up once each, 8 times
Amodeo_long<-data.frame(ID, Wave, Resilience)
#OneWay_mod<-aov(Resilience~Wave + Error(ID/(Wave)), AmodeoSIM)
#summary(OneWay_mod)
#model.tables(OneWay_mod,"means")
str(Amodeo_long)
