library(gplots)
plotmeans (formula = Accurate ~ COND, #plots DV by IV
data = accSIM30, #identifies the data frame
xlab = "Racial Loading Condition", #custom label for the x-axis
ylab = "Accuracy of Confederate's Impression", #custom label for the y-axis
n.label = TRUE  #lists the sample size for each level of the group
)
#this code could be more elegantly written in one row
#plotmeans (formula = Accurate ~ COND, data = accSIM30, xlab = "Racial Loading Condition", ylab = "Accuracy of Confederate's Impression", n.label = TRUE)
boxplot2 (Accurate ~ COND, data = accSIM30, xlab = "Racial Loading Condition", ylab = "Accuracy of Confederate's Impression", n.label = TRUE)
width <- 7
height <- 4
# params
mu <- c(-4, -.25, 3.5)
sig <- 2
# data
x <- seq(-3,3,.1)
x1 <- x*sig + mu[1]
x2 <- x*sig + mu[2]
x3 <- x*sig + mu[3]
y1 <- dnorm( x1, mu[1], sig )
y2 <- dnorm( x2, mu[2], sig )
y3 <- dnorm( x3, mu[3], sig )
# set up window
plot.new() # create graphics device
plot.window(xlim = c(-10,10), ylim = c(0,.25)) # define plot area
axis(side = 1, # axis located below
col = "gray20",  # coloured gray
at = c(-10,mu,10), # tick marks located at
labels = c("","group 1","group 2","group 3","")
)
# plot densities
lines(x1,y1, type = "l", col = "gray20")
lines(x2,y2, type = "l", col = "gray20")
lines(x3,y3, type = "l", col = "gray20")
# arrows
arrows(
mu[1],.15, # from
mu[2],.15, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)
arrows(
mu[2],.125, # from
mu[3],.125, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)
arrows(
mu[1],.1, # from
mu[3],.1, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)
# title
title(main = "Between-group variation\n(i.e., differences among group means)",
font.main = 1)
width <- 7
height <- 4
# params
mu <- c(-4, -.25, 3.5)
sig <- 2
# data
x <- seq(-3,3,.1)
x1 <- x*sig + mu[1]
x2 <- x*sig + mu[2]
x3 <- x*sig + mu[3]
y1 <- dnorm( x1, mu[1], sig )
y2 <- dnorm( x2, mu[2], sig )
y3 <- dnorm( x3, mu[3], sig )
# set up window
plot.new() # create graphics device
plot.window(xlim = c(-10,10), ylim = c(0,.25)) # define plot area
axis(side = 1, # axis located below
col = "gray20",  # coloured gray
at = c(-10,mu,10), # tick marks located at
labels = c("","group 1","group 2","group 3","")
)
# plot densities
lines(x1,y1, type = "l", col = "gray20")
lines(x2,y2, type = "l", col = "gray20")
lines(x3,y3, type = "l", col = "gray20")
# arrows
x <- 1.5
y <- .135
for (i in 1:3) {
arrows(
mu[i]-x,y, # from
mu[i]+x,y, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)  }
GrandMean <- mean(accSIM30$Accurate)
GrandMean
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
library(formattable)
GrandMean <- digits(GrandMean, 3)
GrandMean
library(tidyverse)
accSIM30 <- accSIM30 %>%
dplyr::mutate(m_dev = Accurate-mean(Accurate))
head(accSIM30)
mean(accSIM30$m_dev)
accSIM30 <- accSIM30 %>%
dplyr::mutate(m_devSQ = m_dev^2)
head(accSIM30)
SST <- sum(accSIM30$m_devSQ)
SST
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
SST <- digits(SST,3)
SST
GroupMeans <- aggregate (Accurate ~ COND, accSIM30, mean)
GroupMeans
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
ControlMean <- digits(GroupMeans$Accurate[1],3)
ControlMean
LowMean <- digits(GroupMeans$Accurate[2],3)
LowMean
HighMean <- digits(GroupMeans$Accurate[3],3)
HighMean
nGroup <- accSIM30 %>% count(COND)
nGroup
nControl <- nGroup$n[1]
nControl
nLow <- nGroup$n[2]
nLow
nHigh<- nGroup$n[3]
nHigh
#Calculated by using object names from our calculations
SSM <- nControl*(ControlMean - GrandMean)^2 + nLow*(LowMean - GrandMean)^2 + nHigh*(HighMean - GrandMean)^2
SSM
#calculated by specifying the actual values from our calculations
30*(1.756 - 1.603)^2 + 30*(1.900 - 1.603)^2 + 30*(1.153 - 1.603)^2
#Both result in the same
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
SSM <- digits (SSM,3)
SSM
SDs <- aggregate (Accurate ~ COND, accSIM30, sd)
SDs
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
sdControl <- digits(SDs$Accurate[1],3)
sdControl
sdLow <- digits(SDs$Accurate[2],3)
sdLow
sdHigh <- digits(SDs$Accurate[3],3)
sdHigh
#just showing you that the variance (next) is the standard deviation, squared
sdControl^2#the standard deviation of the control group, when squared should equal the variance reported in the next chunk
VARs <- aggregate (Accurate ~ COND, accSIM30, var)
VARs
#Calculated by using object names from our calculations
SSR <- varControl*(nControl-1) + varLow*(nLow-1) + varHigh*(nHigh-1)
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
varControl <- digits(VARs$Accurate[1],3)
varControl
varLow <- digits(VARs$Accurate[2],3)
varLow
varHigh <- digits(VARs$Accurate[3],3)
varHigh
#Calculated by using object names from our calculations
SSR <- varControl*(nControl-1) + varLow*(nLow-1) + varHigh*(nHigh-1)
#Calculated by specifying the actual values from our calculations
SSR
0.212*(30-1) + 0.397*(30-1) + 0.434*(30-1)
#Both result in the same
# mean squares for the model
#Calculated by using object names from our calculations
MSM <- SSM/dfM
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
#will install the package if not already installed
#if(!require(gplots)){install.packages("gplots")} #easy plotting for simple ANOVA
#if(!require(tidyverse)){install.packages("tidyverse")} #creating new variables and other handy functions
#if(!require(psych)){install.packages("psych")} #for descriptive statistics and writing them as csv files
#if(!require(rstatix)){install.packages("rstatix")} #a number of wrappers for ANOVA models; today for evaluating the Shapiro
#if(!require(lsr)){install.packages("lsr")} #produces effect sizes
#if(!require(pwr)){install.packages("pwr")} #estimating sample sizes and power analysis
#if(!require(apaTAbles)){install.packages("apaTables")} #produces an APA style table for ANOVAs and other models
#if(!require(formattable)){install.packages("formattable")} #produces an APA style table for ANOVAs and other models
#if(!require(effectsize)){install.packages("effectsize")} #produces an APA style table for ANOVAs and other models
#Note, this script results in a different simulation than is in the ReadySetR lesson
set.seed(210820) #sets a random seed so that we get the same results each time
Accurate <- c(rnorm(30, mean=1.18, sd=0.80), rnorm(30, mean=1.83, sd = 0.58), rnorm(30, mean = 1.76, sd = 0.56))#sample size, M and SD for each group
Accurate[Accurate>3]<-3 #set upper bound for DV
Accurate[Accurate<0]<-0 #set lower bound for DV
moreTalk <- c(rnorm(30, mean=-.82, sd=0.91), rnorm(30, mean=-0.39, sd = 0.66), rnorm(30, mean = -0.04, sd = 0.71))#sample size, M and SD for each group
moreTalk[moreTalk>2]<- 2 #set upper bound for DV
moreTalk[moreTalk<-2]<- -2 #set lower bound for DV
ID<-factor(seq(1,90)) #IDs for participants
COND<-c(rep("High", 30), rep("Low", 30), rep("Control", 30)) #name factors and identify how many in each group; should be in same order as first row of script
accSIM30 <-data.frame(ID, COND, Accurate, moreTalk) #groups the 3 variables into a single df:  ID#, DV, condition
str(accSIM30)
#convert variable  to factor
accSIM30$COND <- factor(accSIM30$COND)
str(accSIM30)
#ordering the factor
accSIM30$COND <- factor(accSIM30$COND, levels = c("Control", "Low", "High"))
#another structure check
str(accSIM30)
#write the simulated data  as a .csv
#write.table(accSIM30, file="accSIM.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
#acc_csv <- read.csv ("accSIM.csv", header = TRUE)
#a quick demo to show that the .csv format loses the variable formatting
#str(acc_csv)
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
#saveRDS(accSIM30, "accSIM.rds")
#bring back the simulated dat from an .rds file
#acc_RDS <- readRDS("accSIM.rds")
#a quick demo to show that the .rds format preserves the variable formatting
#str(acc_RDS)
#accSIM30 <- acc_RDS
#or
#accSIM30 <- acc_csv
aggregate(Accurate ~ COND, accSIM30, mean)
aggregate(Accurate ~ COND, accSIM30, sd)
library(gplots)
plotmeans (formula = Accurate ~ COND, #plots DV by IV
data = accSIM30, #identifies the data frame
xlab = "Racial Loading Condition", #custom label for the x-axis
ylab = "Accuracy of Confederate's Impression", #custom label for the y-axis
n.label = TRUE  #lists the sample size for each level of the group
)
#this code could be more elegantly written in one row
#plotmeans (formula = Accurate ~ COND, data = accSIM30, xlab = "Racial Loading Condition", ylab = "Accuracy of Confederate's Impression", n.label = TRUE)
boxplot2 (Accurate ~ COND, data = accSIM30, xlab = "Racial Loading Condition", ylab = "Accuracy of Confederate's Impression", n.label = TRUE)
width <- 7
height <- 4
# params
mu <- c(-4, -.25, 3.5)
sig <- 2
# data
x <- seq(-3,3,.1)
x1 <- x*sig + mu[1]
x2 <- x*sig + mu[2]
x3 <- x*sig + mu[3]
y1 <- dnorm( x1, mu[1], sig )
y2 <- dnorm( x2, mu[2], sig )
y3 <- dnorm( x3, mu[3], sig )
# set up window
plot.new() # create graphics device
plot.window(xlim = c(-10,10), ylim = c(0,.25)) # define plot area
axis(side = 1, # axis located below
col = "gray20",  # coloured gray
at = c(-10,mu,10), # tick marks located at
labels = c("","group 1","group 2","group 3","")
)
# plot densities
lines(x1,y1, type = "l", col = "gray20")
lines(x2,y2, type = "l", col = "gray20")
lines(x3,y3, type = "l", col = "gray20")
# arrows
arrows(
mu[1],.15, # from
mu[2],.15, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)
arrows(
mu[2],.125, # from
mu[3],.125, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)
arrows(
mu[1],.1, # from
mu[3],.1, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)
# title
title(main = "Between-group variation\n(i.e., differences among group means)",
font.main = 1)
width <- 7
height <- 4
# params
mu <- c(-4, -.25, 3.5)
sig <- 2
# data
x <- seq(-3,3,.1)
x1 <- x*sig + mu[1]
x2 <- x*sig + mu[2]
x3 <- x*sig + mu[3]
y1 <- dnorm( x1, mu[1], sig )
y2 <- dnorm( x2, mu[2], sig )
y3 <- dnorm( x3, mu[3], sig )
# set up window
plot.new() # create graphics device
plot.window(xlim = c(-10,10), ylim = c(0,.25)) # define plot area
axis(side = 1, # axis located below
col = "gray20",  # coloured gray
at = c(-10,mu,10), # tick marks located at
labels = c("","group 1","group 2","group 3","")
)
# plot densities
lines(x1,y1, type = "l", col = "gray20")
lines(x2,y2, type = "l", col = "gray20")
lines(x3,y3, type = "l", col = "gray20")
# arrows
x <- 1.5
y <- .135
for (i in 1:3) {
arrows(
mu[i]-x,y, # from
mu[i]+x,y, # to
code = 3,  # arrows on both ends
lwd = 2,   # thick line
)  }
GrandMean <- mean(accSIM30$Accurate)
GrandMean
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
library(formattable)
GrandMean <- digits(GrandMean, 3)
GrandMean
library(tidyverse)
accSIM30 <- accSIM30 %>%
dplyr::mutate(m_dev = Accurate-mean(Accurate))
head(accSIM30)
mean(accSIM30$m_dev)
accSIM30 <- accSIM30 %>%
dplyr::mutate(m_devSQ = m_dev^2)
head(accSIM30)
SST <- sum(accSIM30$m_devSQ)
SST
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
SST <- digits(SST,3)
SST
GroupMeans <- aggregate (Accurate ~ COND, accSIM30, mean)
GroupMeans
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
ControlMean <- digits(GroupMeans$Accurate[1],3)
ControlMean
LowMean <- digits(GroupMeans$Accurate[2],3)
LowMean
HighMean <- digits(GroupMeans$Accurate[3],3)
HighMean
nGroup <- accSIM30 %>% count(COND)
nGroup
nControl <- nGroup$n[1]
nControl
nLow <- nGroup$n[2]
nLow
nHigh<- nGroup$n[3]
nHigh
#Calculated by using object names from our calculations
SSM <- nControl*(ControlMean - GrandMean)^2 + nLow*(LowMean - GrandMean)^2 + nHigh*(HighMean - GrandMean)^2
SSM
#calculated by specifying the actual values from our calculations
30*(1.756 - 1.603)^2 + 30*(1.900 - 1.603)^2 + 30*(1.153 - 1.603)^2
#Both result in the same
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
SSM <- digits (SSM,3)
SSM
SDs <- aggregate (Accurate ~ COND, accSIM30, sd)
SDs
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
sdControl <- digits(SDs$Accurate[1],3)
sdControl
sdLow <- digits(SDs$Accurate[2],3)
sdLow
sdHigh <- digits(SDs$Accurate[3],3)
sdHigh
#the standard deviation of the control group, when squared should equal the variance reported in the next chunk
sdControl^2
VARs <- aggregate (Accurate ~ COND, accSIM30, var)
VARs
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
varControl <- digits(VARs$Accurate[1],3)
varControl
varLow <- digits(VARs$Accurate[2],3)
varLow
varHigh <- digits(VARs$Accurate[3],3)
varHigh
#Calculated by using object names from our calculations
SSR <- varControl*(nControl-1) + varLow*(nLow-1) + varHigh*(nHigh-1)
#Re-calculated by specifying the actual values from our calculations
SSR
0.212*(30-1) + 0.397*(30-1) + 0.434*(30-1)
#Both result in the same
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
dfT <- 89
dfM <- 2
dfR <- 87
#Calculated by using object names from our calculations
SSM + SSR
#Re-calculated by specifying the actual values from our calculations
9.432 + 30.247
#Both result in the same
# mean squares for the model
#Calculated by using object names from our calculations
MSM <- SSM/dfM
MSM
#Re-calculated by specifying the actual values from our calculations
9.432/2
#Both result in the same
#Calculated by using object names from our calculations
Fratio <- MSM / MSR
# mean squares for the residual
#Calculated by using object names from our calculations
MSR <- SSR/ dfR
MSR
#calculated by specifying the actual values from our calculations
30.247/87
#Both result in the same
#Calculated by using object names from our calculations
Fratio <- MSM / MSR
Fratio
#calculated by specifying the actual values from our calculations
4.716/0.348
#Both result in the same
#looking up the F critical values
qf(.05, 2, 87, lower.tail=FALSE)#Model F critical value
#we name the function
#in parentheses we list the object that is the dataframe
#the $ sign precedes the specific variable for which we want the information
psych::describe(accSIM30$Accurate)
#It is unnecessary to create an object, but an object allows you to do cool stuff, like write it to a .csv file and use that as a basis for APA style tables
#In this script we can think "Accurate by COND" meaning that the descriptives for accuracy will be grouped by COND which is a categorical variable
#mat = TRUE means we will get the output in matrix (table) form
#digits = 3 means output will be rounded to 3 decimal places
#data = accSIM30 is a different (I think easier) way to identify the object that holds the dataframe
des.mat <- psych::describeBy (Accurate ~ COND, mat=TRUE, digits=3, data=accSIM30)
#describeBy(accSIM30$Accurate, accSIM30$COND, mat=TRUE)
des.mat #let's you see the matrix object
write.csv (des.mat, file="Table1.csv") #optional to write it to a .csv file
#library(rstatix)
shapiro <- accSIM30 %>%
group_by(COND) %>%
rstatix::shapiro_test(Accurate)
shapiro
shapiro <- accSIM30 %>%
group_by(COND) %>%
rstatix::shapiro_test(Accurate)
shapiro
#Our set up is similar:  Accurate by condition, followed by the object that holds the dataframe, followed by the instruction to center the analysis around the mean
levene <- car::leveneTest (Accurate ~ COND, accSIM30, center=mean)
levene
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
df1levene<- digits(levene$Df[1],0)
df1levene
df2levene<- digits(levene$Df[2],0)
df2levene
Flevene <- digits(levene$"F value"[1],3)
Flevene
plevene <- digits(levene$"Pr(>F)"[1],3)
plevene
#the script looks familiar, "Accurate by Condition"
omnibus <- aov(Accurate ~ COND, data = accSIM30) #DV ~ IV  I say, "DV by IV"
summary (omnibus) #prints the ANOVA output
#this script is used for the inline coding in the lesson and, although you will want to run it so you can "feed" the objects into later script, there is no "lesson" relative to this lecture
df1omnibus<- digits(summary(omnibus)[[1]][1, "Df"],0)
df1omnibus
df2omnibus<- digits(summary(omnibus)[[1]][2, "Df"],0)
df2omnibus
SSMomnibus<- digits(summary(omnibus)[[1]][1, "Sum Sq"],3)
SSMomnibus
SSRomnibus<- digits(summary(omnibus)[[1]][2, "Sum Sq"],3)
SSRomnibus
SSTomnibus <- digits((SSMomnibus + SSRomnibus),3)
SSTomnibus
MSMomnibus<- digits(summary(omnibus)[[1]][1, "Mean Sq"],3)
MSMomnibus
MSRomnibus<- digits(summary(omnibus)[[1]][2, "Mean Sq"],3)
MSRomnibus
Fomnibus<- digits(summary(omnibus)[[1]][1, "F value"],3)
Fomnibus
pomnibus<- digits(summary(omnibus)[[1]][1, "Pr(>F)"],3)
pomnibus
names(omnibus)
model.tables (omnibus, "means")
plot(omnibus)
#Calculated using the object names
SSMomnibus / (SSMomnibus + SSRomnibus)
#Calculated by using the numeric values
9.432/(9.432 + 30.246)
#Optiosn should produce the same result
#Re-calculated by using the numeric values
9.432/(9.432 + 30.246)
#Both options should produce the same result
lsr::etaSquared(omnibus)
pairwise.t.test(accSIM30$Accurate, accSIM30$COND, p.adj = "none")
#can swap "bonf" or "holm" for p.adj
citr:::insert_citation()
summary.lm(omnibus)
#Contrast1  compares Control against the combined effects of Low and High.
contrast1 <- c(-2,1,1)
#Contrast2 excludes Control; compares Low to High.
contrast2 <- c(0,-1,1)
#binding the contrasts together
contrasts(accSIM30$COND)<-cbind(contrast1, contrast2)
accSIM30$COND
#create a new object, the ANOVA looks the same, but it will now consider the contrasts (this is where order-of-operations matters)
accPlanned <- aov(Accurate ~ COND, data = accSIM30)
summary.lm(accPlanned)
contrasts(accSIM30$COND)<-cbind(c(-2,1,1), c(0,-1,1))
oneway.test (Accurate ~ COND, data = accSIM30)
effectsize::eta2_to_f(.238)
library(pwr)
pwr.anova.test (k = 3, f = .5589, sig.level = .05, power = .80)
pwr::pwr.anova.test (k = 3, f = .5589, sig.level = .05, power = .80)
pwr::pwr.anova.test (k = 3, f = .1, sig.level = .05, power = .80)
pwr::pwr.anova.test (k = 3, f = .1, sig.level = .05, power = .80)
# table.number = 1 assigns a table number to the top of the table
# filename = "Table1.doc" writes the table to Microsoft Word and puts it in your project folder
apaTables::apa.1way.table(iv=COND, dv=Accurate, show.conf.interval = TRUE, data=accSIM30, table.number = 1, filename = "Table1.doc")
1.76 - 1.15#calculating mean difference between control and high
1.90 - 1.15#calculating mean difference between low and high
1.76 - 1.90#calculating mean difference between  control and low
apaTables::apa.aov.table (omnibus, table.number = 2, filename = "Table2.doc")
plotmeans (formula = Accurate ~ COND, data = accSIM30, xlab = "Racial Loading Condition", ylab = "Accuracy of Confederate's Impression", n.label = FALSE)
lsr::etaSquared(omnibus)
